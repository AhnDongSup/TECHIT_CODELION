# TDD

배포할 파일(TDD.html)과 테스트할 파일(TDD.spec.js)로 나뉨

TDD 단계
🔴 적색 단계 : 성공하기 위해 테스트 실패하는 단계
🟢 녹색 단계 : 테스트에 성공하는 단계
🟣 리팩터 단계 : 테스트에 성공한 코드를 기반으로 코드의 품질을 높이는 단계 refactoring

---
```html
<body>
    <article>
      <strong class="viewer">hello lions!</strong>
      <input type="text" class="inp-txt">
      <!-- 서로 다른 언어가 섞여있습니다. -->
      <button class="btn-push" onclick=push()>적용</button>
    </article>
    <script>
      // 함수 밖의 내용들은 테스트가 불가능합니다.
      let txt = "hello lions!!";
      const viewer = document.querySelector('.viewer')
      viewer.textContent = txt;
      // 재사용성이 떨어진다. inp-txt 라는 클래스를 가진 요소가 존재해야만 한다!
      function push() {
        const inpTxt = document.querySelector('.inp-txt');
        viewer.textContent = inpTxt.value;
      }
      // 테스트 가능한 코드란!
      // 1. 테스트할 코드를 UI에서 완전히 분리해야합니다.
      // 2. 자바스크립트를 JS파일로 따로 분리해야합니다.
      // 3. 모든 기능은 함수로 구현합니다.
    </script>
  </body>
```

테스트할 내용이 함수 안에 들어가 있는게 좋다

즉, 함수 밖에 있는 내용은 테스트하기가 어렵다
(전역에 선언하는 것은 테스트가 어렵다)

html에 onclick과 같이 js와 같이 언어를 섞어서 쓰면
이것또한 테스트하기가 어렵다


constructor 
생성자함수를 만들때 자동으로 실행

---

###  toThrowError()

함수는 실행되는 함수가 예외를 발생시키는지를 검증하는 함수입니다. 실행되는 함수가 예외를 발생시키지 않으면 테스트가 실패하게 됩니다.

---

# 컴파일 언어와 인터프리터언어

## 컴파일 언어

컴파일이 존재하는 언어
컴파일러가 하는 일은
사람이 작성한 코드를 기계어로 바꾸어준다

작성한 코드를 기계어로 바꾸는 과정중에
에러가 있으면 미리 잡아줌
컴파일 하는 과정에서 나는 에러를 컴파일 에러

1. 컴파일러가 존재하기 때문에 예를 들어 자바를 컴파일 하는 과정에서 어느정도 오류가 잡힘
2. 컴파일로 생성된 exe 파일은 기계어로 되어있기때문에 바로 실행이가능

## 인터프리터언어

자바스크립트는 인터프리터 언어인데
브라우저에 있는 엔진이 해석하기 때문에
브라우저가 해석하고 실행함
엔진이 한줄 한줄 보면서 브라우저에게 넘기기 때문에
실시간 통역가 처럼
그때그때 번역하고 실행함
따라서, 컴파일 언어에 비해 속도가 많이 차이난다
컴파일러가 없기때문에 따로 작성한 코드에서
문법적인 에러가 있는지 확인 할 수 없다

---

## TDD의 장점

1. 자바스크립트는 인터프리터 언어. 컴파일러의 역할을 테스트를 통해 대신 수행하여 기능의 구동을 보장합니다. 이는 곧 코드를 안정적이고 견고하게 만들어 줍니다.
2. 구현해야 하는 기능에 대한 높은 분석을 요구하기 때문에 서비스에 대한 이해도가 상승하고 품질을 우선하는 사고를 하게됩니다.

## TDD를 사용할 때 주의해야할 점

1. 테스트 코드를 따로 작성해야 하기 때문에 시간이 더 들어가고 이는 곧 업무에 대한 부담으로 다가옵니다. 때문에 프로젝트가 급박하다면 TDD 를 사용하지 않는 편이 좋습니다. 프로젝트의 성격에 따라 신중히 판단해야합니다.
2. TDD 가 모든 예외 상황을 해결해주지는 않습니다. 결국 테스트 코드를 작성하는 사람이 고려하지 않은 상황은 테스트 코드도 놓칠 수 있기 때문에 테스트 코드를 작성했다고 해서 방심할 수는 없습니다. 테스트 코드는 견고하고 안정적인 코드를 지향하는 것이지 결코 완벽하진 않습니다.

---

# Jest

- **Test** **함수** : 글로벌 함수. 두 가지 인자를 가집니다. 첫번째 인자는 문자열로 테스트의 설명입니다. 자스민에서는 describe 입니다. 두번째 인자는 테스트를 실행하는 테스트 함수입니다.
- **Render 함수** : 인자로 받는 JSX의 가상돔을 생성합니다. 여기서는 app 컴포넌트를 전달받습니다.
- **Screen** : 생성된 가상돔에 접근하기 위한 전역 객체입니다.

- **getByText 함수** : 인자로 전달된 텍스트를 가지는 돔 안의 요소를 찾습니다. 여기서는 정규표현식을 사용했군요. /learn react/i 뒤에 붙은 i는 대소문자를 구분하지 않겠다는 의미입니다.
- **expect 함수** : 익숙하죠? 제스민에도 있었습니다. 기대한 결과가 성공인지 실패인지 판단하는 함수입니다.
- **.toBeInTheDocument** : matcher 함수입니다. 제스민의 .toBe() 함수가 기억나시나요? 제스트에도 존재합니다.



---

## testing-library

테스트에 도움이되는 것들 을 제공해주는 라이브러리

---

https://www.w3.org/TR/html-aria/#docconformance

코드에서 요소를 찾을 때 getByRole 로 찾는 것이 보입니다. role은 aria에서 사용하는 요소의 역할을 의미하는 속성입니다. 특정 요소는 role 을 명시하지 않아도  암묵적으로 가지고 있는 경우도 있습니다.

---

