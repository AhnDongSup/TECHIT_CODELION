# useMemo

https://www.inflearn.com/course/lecture?courseSlug=%EC%A0%9C%EC%A3%BC%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-100%EC%A0%9C&unitId=56395&tab=curriculum
무거운 계산을 반복적으로 해야할 때 좋다
최적화를 할 때 쓰는 

버튼을 누를 때 업데이트가 되도록

---

#  가상 돔

리액트에서는 가상 돔이라는것을 사용합니다. 이것은 기존 돔과는 다르게 가벼운 정보만 가지고 있어서 빠르게 비교가 가능합니다. 챕터 1에서 언급한 바 있습니다.

비교에 필요없는 부분들은 빼버린 가상 돔을 이용해 실제 비교에 필요한 부분들만 비교합니다.
최초 렌더링 → 이전 렌더링부분에 가상 돔 저장 → 상태 업데이트 → 상태 업데이트로 인한 가상 돔 렌더링 → 업데이트로 인해 렌더링된 가상 돔과 이전에 만들어진 가상 돔을 비교 → 바뀐 부분 브라우저에 렌더링

---

# form 에 onSubmit 에 달아야하는 이유

form안에 자식요소를 보로 수 있고

---

# useMemo

`useMemo`도 `useEffect`와 비슷한 부분이 많습니다. state가 있는 컴포넌트에 state 변화가 생기면 재평가 후 새로 랜더링을 하기 때문이죠. 어떤 부분이 다른지 왜 이 두 가지로 분리되었는지는 뒤에서 차근차근 살펴보겠습니다.

useMemo는 컴포넌트 성능 최적화에 사용됩니다. Memo는 memoization이라는 기법을 사용합니다.

메모이제이션 기법을 사용하는 대표적인 예로 재귀함수의 피보나치 순열이 있는데요. 피보나치 순열을 재귀로 호출하게 되면 많은 함수가 반복됩니다. 그런데 그러한 결과값을 어떠한 object에 가지고 있다면 반복할 필요가 없습니다. 이렇게 어떤 부하가 생기는 함수를 반복해서 작업할 때 기억해두었다가 사용하는 기법을 말합니다. 렌더링이 될 때 이전에 작업해두었던 결과값을 가지고 있다가 반영해주는 것이죠.

---

### 4.1 useMemo

`useMemo(실행될 것, [값])`라고 할 때 `useMemo`는 렌더링 전에 실행되어 메모이제이션한 것을 반환해줍니다. 값이 바뀌었는지 확인하고 **렌더링 전**에 저장된 것을 보내주는 것이죠.

### 4.2 useEffect

반면 `useEffect`는 **렌더링 후**에 일어납니다. 렌더링 후에 **상태가 업데이트 되었을 때를 감지**하여 동작합니다.

### 4.3 차이점

`useMemo`는 렌더링에 직접적인 영향을 미칠 수 있습니다. 예를들면, 콜백함수에서 컴포넌트 등을 반환하게 했을 때, 렌더링하기 이전에 저장된 값을 확인하여 변화가 없으면 리렌더링을 하지 않도록 할 수 있기 때문이죠.

반면 `useEffect`는 렌더링한 이후에 동작되기 때문에 리렌더링을 방지하지 못합니다. 

즉, `useMemo`는 리렌더링이나 불필요한 재실행 과정을 막는 방법(최적화)에 사용하기 적합하고, `useEffect`는 상태를 이용한 관리에 사용됩니다.

### 4.4 요약

- 렌더링 전 : `useMemo` / 렌더링 후 : `useEffect`
- 상태 변화를 감지하여 경우에 따라 콜백함수를 호출하고 싶다면 `useEffect`
- 값을 저장하여 불필요한 동작 또는 렌더링을 막아 최적화하고 싶다면 `useMemo`

---

# useMemo

리렌더링을 하지 않도록 함 수 있음

---

정리해보겠습니다!

1. Context.Provider는 컴포넌트 계층 구조에서 Context 객체를 전달하는 역할을 합니다. Provider를 사용하여 Context를 구독하는 모든 하위 컴포넌트들이 Provider가 제공하는 값을 사용할 수 있게 됩니다.
2. Context.Consumer는 Context를 구독하는 컴포넌트입니다. Consumer를 사용하여 Provider에서 전달받은 Context 값을 사용할 수 있습니다. Consumer는 Provider로부터 값을 받아올 때 콜백 함수를 사용합니다. 이 콜백 함수의 인자로 전달되는 값은 Provider에서 전달한 Context 값이 됩니다.

Provider는 Context 값을 제공하고 Consumer는 해당 값을 사용하는 역할을 하며, 이 둘을 결합하여 props를 사용하지 않고도 컴포넌트 트리의 어디에서든 Context 값을 사용할 수 있습니다.

단, 이는 전역 공간을 사용하는것이기 때문에 반드시 필요한 데이터가 아니라면 사용을 최소화 하는것이 좋습니다!

props drilling 이 두 단계를 초과하지 않는다면 꼭 사용할 필요는 없습니다.

