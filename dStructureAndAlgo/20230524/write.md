# 자료구조

데이터를 저장하고 관리하는 방법론.

데이터를 저장하는 컨테이너는 많지만 우리는 우리가 사용할 데이터에 따른, 그리고 필요한 상황에 맞는 올바른 자료구조를 사용해야합니다.

마치 일상생활에서 소고기를 보관하는데 반드시 냉장고를 사용해야 하는것 처럼요.

자료구조에는 우리가 사용하는 모든 데이터 타입을 저장합니다.

그리고 마치 우리가 어지러운 방을 가지런히 정리하는것 처럼  정리하기도 합니다.

---

# Big O란 무엇일까?

Big O 표기법은 알고리즘이 최악의 경우 얼마나 복잡해질지 나타냅니다.

Big O는 알고리즘의 실행에 필요한 시간을 정의합니다. 입력 크기가 증가함에 따라(얼마나 많은 데이터를 처리하는가) 알고리즘의 성능이 어떻게 변경되는지를 나타냅니다.

Big O 표기법은 시간 및 공간 복잡성을 사용하여 알고리즘의 효율성과 성능을 측정합니다.

## 시간 및 공간 복잡성은 무엇인가?

프로그램의 성능과 효율성에 영향을 주는 주요한 요인은 하드웨어, 운영 체제 및 CPU입니다.

그러나 알고리즘의 성능을 분석할 때는 이러한 요소를 고려하지 않습니다. 대신, 입력 크기에 따라 표현되는 시간 및 공간 복잡성이 중요합니다.

알고리즘의 시간 복잡성은 입력 크기로서 알고리즘이 실행되는 데 걸리는 시간을 의미합니다. 마찬가지로, 알고리즘의 공간 복잡성은 알고리즘이 실행되는 데 필요한 메모리 양을 말합니다.

오늘날의 컴퓨터 하드웨어는 예전에 비해 성능이 아주 향상되었기 때문에 개발할때는 주로 시간 복잡성에 초점을 맞추는 편입니다.

---

O(1) 얼마나 많은 데이터를 넣은 배열이건 엑세스하는 시간은 똑같다

O(n) 들어가는 값이 많으면 많을 수록 걸리는 시간은 비례한다

# Big O 표기법에서는 시간 및 공간 복잡성의 여섯 가지 주요 유형이 있습니다:

1. 상수 시간(Constant): O(1)
    - 상수 시간 복잡도는 입력 크기에 관계없이 실행 시간이 일정한 알고리즘을 나타냅니다.
    - 즉, 입력 크기에 관계없이 실행 시간이 일정하므로 가장 효율적인 알고리즘입니다.
    - 예를 들어, 배열에서 첫 번째 요소를 반환하는 경우와 같이 단일 작업을 수행하는 알고리즘이 이에 해당합니다.
2. 선형 시간(Linear time): O(n)
    - 선형 시간 복잡도는 입력 크기에 비례하여 실행 시간이 증가하는 알고리즘을 나타냅니다.
    - 예를 들어, 배열의 모든 요소를 한 번씩 방문하면서 처리하는 경우, 배열의 요소가 늘어날 수록 처리해야 하는 시간도 비례해서 늘어나는것이 선형 시간 알고리즘입니다.
3. 로그 시간(Logarithmic time): O(n log n)
    - 로그 시간 복잡도는 입력 크기에 비례하여 실행 시간이 증가하는것으로 선형시간과 비슷하지만, 선형 시간보다는 느립니다.
    - 주로 분할 정복(divide and conquer) 알고리즘에서 나타닙니다.
4. 이차 시간(Quadratic time): O(n^2)
    - 이차 시간 복잡도는 입력 크기의 제곱에 비례하여 실행 시간이 증가하는 알고리즘을 나타냅니다.
    - 즉, 입력 크기가 증가할수록 실행 시간이 기하급수적으로 증가합니다.
    - 예를 들어, 이중 반복문을 사용하여 배열의 모든 요소 쌍을 확인하는 경우 이차 시간 알고리즘입니다.
5. 지수 시간(Exponential time): O(2^n)
6. 팩토리얼 시간(Factorial time): O(n!)

---

# Array와 HashTable

자바스크립트는 Array와 Object(HashTable)를 기본적으로 제공합니다. Array는 정렬된 값의 집합이며, Object(HashTable)는 key-value 형태의 데이터를 저장하는 데 사용됩니다. 또한, ES6에서는 Set과 Map이 추가되었는데, Set은 중복 없이 유일한 값을 저장하는 자료구조이며, Map은 key-value 형태의 데이터를 저장하는 자료구조입니다. 

그러나 이 외에도 다양한 자료구조들이 존재하며, 자바스크립트에서도 이를 구현하거나 라이브러리를 통해 사용할 수 있습니다. 예를 들어, Stack, Queue, Linked List, Tree, Graph 등의 자료구조들이 있습니다. 일부 자료구조는 JavaScript에서 기본 제공되지 않아서 직접 구현해야 하거나, 라이브러리를 사용해야 합니다.

---

* 주의!!! 배열(Array)의 삽입(Insertion)과 추가(Push)는 서로 다른 개념입니다.

배열의 삽입(Insertion):

배열의 삽입은 배열의 특정 위치에 요소를 추가하는 작업을 말합니다.
이 작업은 새로운 요소를 배열 중간이나 특정 인덱스에 삽입하는 경우에 사용됩니다.
삽입 작업을 수행하려면 기존 요소들을 오른쪽으로 이동시켜 공간을 만들어야 합니다.
예를 들어, 만약 배열 [1, 2, 3, 4, 5]에 인덱스 2에 10을 삽입한다면, 결과는 [1, 2, 10, 3, 4, 5]가 됩니다.
배열의 삽입은 시간 복잡도가 O(n)입니다. 왜냐하면 삽입 위치 이후의 모든 요소들을 이동시켜야 하기 때문입니다.


배열의 추가(Push):

배열의 추가는 배열의 끝에 새로운 요소를 추가하는 작업을 말합니다.
이 작업은 배열의 크기를 동적으로 관리하는 동적 배열(Dynamic Array)에서 주로 사용됩니다.
추가 작업은 배열의 마지막에 요소를 삽입하여 배열의 길이를 1만큼 증가시킵니다.
예를 들어, 만약 배열 [1, 2, 3]에 4를 추가한다면, 결과는 [1, 2, 3, 4]가 됩니다.
배열의 추가는 평균적으로 시간 복잡도가 O(1)입니다. 동적 배열의 경우, 추가 작업이 배열의 크기를 초과하게 되면 더 큰 배열을 할당하고 기존 요소들을 복사해야 하므로 최악의 경우에는 O(n)의 시간 복잡도가 발생할 수도 있습니다.
따라서, 배열의 삽입과 추가는 다른 개념이며, 삽입은 중간이나 특정 위치에 요소를 추가하는 작업을 의미하고, 추가는 배열의 끝에 요소를 추가하는 작업을 의미합니다.

---

## 세미클론

let a = 'hello'
let b = 'lions'
[a, b] = [b, a]

console.log(a)
console.log(b)

가 작동하지 않는이유

let a = 'hello'
let b = 'lions'[a, b] = [b, a]

console.log(a)
console.log(b)

; 이 없어서 이런식으로 작동되는 것이다
let b의 선언이 끝나지 않았다고 판단해서
문자열의 인덱스에 접근하는것처럼 인식하는 것이다

---

http://www.yes24.com/Product/Goods/15968612

---


### **가장 기본이 되는 자료구조**

1. Queue
    
    FIFO(파이포) : first in first out
    
    데이터를 저장할 때 먼저 저장된 데이터를 먼저 처리하는 방식
    
    놀이공원에서 줄을 설 때 먼저 온 사람이 먼저 들어가는 방식으로 생각하면 편합니다.
    
    큐에 새롭게 데이터를 추가하는것을 인큐(enqueue), 데이터가 처리되어 제거되는것을 디큐(dequeue) 라고 합니다.
    
2. Stack
    
    LIFO(라이포) : last in first out
    
    큐와 반대되는 자료구조입니다. 먼저 저장된 데이터를 가장 나중에 처리하고 나중에 들어온 데이터를 먼저 처리합니다. 스택에 쌓인 데이터를 표현할 때 프레임이라고 부릅니다.
    
    스택의 처리 순서는 총알을 장전하는 원리와 같다고 보시면 됩니다. 총알을 장전할 때 가장 먼저 장전한 총알이 가장 나중에 발사되고, 가장 나중에 장전한 총알이 먼저 발사됩니다.
    
    스택에 데이터를 추가하는것을 푸쉬, 제거하는 것을 팝이라고 합니다.
    
3. Heap
    
    힙은 이진 트리의 일종으로, 최댓값이나 최솟값을 빠르게 찾을 수 있도록 설계된 자료구조입니다. 이진 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조입니다. 힙은 데이터를 추가하거나 처리하는데 정해진 순서가 존재하지 않습니다. 
    
4. Array
    
    데이터를 순서에 따라 저장하는 자료구조. 다른말로 리스트라고 부르기도 합니다. 가장 폭넓게 기본적으로 사용되는 자료구조입니다.
    
5. hashTable
    
    키와 값의 쌍을 저장하는 자료 구조입니다. 해시 테이블은 해시 함수를 사용하여 키를 해시값으로 변환한 다음, 해시값을 사용하여 키와 값의 쌍을 저장합니다.

    주어준 키를 해시 함수의 로직을 이용해서 특정한 난수로 반환하고
    그 난수를 가지고 저장된 메모리 주소로 사용한다




